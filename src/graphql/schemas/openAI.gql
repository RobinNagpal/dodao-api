type OpenAIChoiceLogprobs {
  tokens: [String!]
  token_logprobs: [Float!]
  top_logprobs: [Any!]
  text_offset: [Int!]
  text: String
}

type CreateCompletionResponseChoice {
  finish_reason: String
  index: Int
  text: String
  logprobs: OpenAIChoiceLogprobs
}


type OpenAIUsage {
  prompt_tokens: Int!
  completion_tokens: Int!
  total_tokens: Int!
}

type OpenAICompletionResponse {
  id: ID!
  object: String!
  created: Int!
  model: String!
  usage: OpenAIUsage
  choices: [CreateCompletionResponseChoice!]!
}

type OpenAIChatCompletionChoice {
  message: OpenAIMessage
  finish_reason: String
  index: Int
}

type OpenAIMessage {
  role: String!
  content: String
}


type OpenAIChatCompletionResponse {
  id: ID!
  object: String!
  created: Int!
  model: String!
  usage: OpenAIUsage
  choices: [OpenAIChatCompletionChoice!]!
}



enum  ChatCompletionRequestMessageRoleEnum {
  system
  user
  assistant
}

extend type Mutation {
  askChatCompletionAI(input: ChatCompletionAIInput!): OpenAIChatCompletionResponse!
  askCompletionAI(input: CompletionAIInput!): OpenAICompletionResponse!
  downloadAndCleanContent(input: String!): String!
  createSummaryOfContent(input: String!): String!
  extractRelevantTextForTopic(input: ExtractRelevantTextForTopicInput!): String!
}


input CompletionAIInput {
  model: String
  prompt: String!
}

input ChatCompletionAIInput {
  model: String
  messages: [OpenAIChatMessageInput!]!
}

input OpenAIChatMessageInput {
  role: ChatCompletionRequestMessageRoleEnum!
  content: String!
}

input ExtractRelevantTextForTopicInput{
  topic: String!
  content: String!
}
